O predicado $possEntityRel(r_l,e_i,e_k) | r_l \in Relation \wedge  e_i, e_k \in Entity$ é usado para, tratar questões de identificar as duas entidades com a sua relação. Esse predicado se lê da seguinte forma: O relacionamento $r_l$ possui a entidade $e_i$ e a entidade $e_k$. Para demonstrar como se dá o uso desse predicado pode-se considerar o \textbf{Exemplo da Redação}. A entidade $alexandre$ apresenta uma relação com $folha$ que é identificada como $relAlexandreFolha$. Portanto, com o predicado, a representação fica; $possEntityRel(relAlexandreFolha,alexandre,folha)$

O predicado $adoptsRole(ag_n,\rho_m) | ag_n \in Agent \wedge \rho_m \in Role$ que tem sua origem nos estudos do \textit{MOISE+} onde cada agente tem uma função dentro do contexto do \textit{SMA}. Esse predicado se lê da seguinte forma: O agente $ag_n$ tem um papel $\rho_m$. Usando o \textbf{Exemplo da Redação} tem-se o seguinte: $adoptsRole(artistoteles,professor)$. 

O predicado $hasObligation(\rho_m,g_j) | \rho_m \in Role, g_j \in Goal $ tem suas origens nos estudos da lógica deôntica também presentes no modelo \textit{MOISE+}. Esse predicado pode ser lido da seguinte maneira: O agente que assumir o papel $\rho_m$ tem a obrigação de concluir o objetivo $g_j$. No exemplo padrão deste texto (\textbf{Exemplo da Redação}), o primeiro objetivo é uma obrigação do professor, portanto: $hasObligation(professor,g_0)$

O predicado $hasPermission(\rho_m, g_j) | \rho_m \in Role, g_j \in Goal $ também está associado aos estudos da lógica deôntica relacionada ao \textit{MOISE+}. A leitura se dá desta maneia: O agente que $\rho_m$ tem a permissão de concluir o objetivo $g_j$. Usando o exemplo padrão como base onde $professor$ tem a obrigação de executar $g_0$, então também tem permissão para isso (isso será melhor explicado em uma regra que será apresentada mais tarde). Portanto; $hasPermission(professor,g_0)$.  

O predicado $instanceOfCond(circ_k)$, $circ_k \in Condition$ informa que $circ_k$ é uma condição, ou seja, pertence ao conjunto Conditions. A existência desse predicado é necessária porque alguns raciocínios de violação necessitam verifcar se o elemento em análise é uma condição. A mesma situação acontece para as relações. Assim sendo o predicado $ instanceOfRel(r_k) \in Relation $ também deve fazer parte da estrutura do modelo.

O predicado $reached(g_k) | g_k \in Goal $ define que todos os agentes, que eram obrigados a alcançar o objetivo $g_k$, concluíram. A existência desse predicado se dá devido ao fato de que em certos raciocínios é necessário identificar que um certo objetivo foi atingido. 

O predicado $stopped(g_n, ag_m) | g_n \in Goal, ag_m \in Agent$ apresenta a seguinte leitura: Toda a atividade foi encerrada com o objetivo $g_n$ por uma ação associada ao agente $ag_m$. Para certos raciocínios se faz necessário identificar o encerramento das atividades como um todo e por quem isso aconteceu. Em certos casos não há a necessidade de identificar o agente $ag_m$. Para isso há uma outra versão deste mesmo predicado escrito da seguinte forma: $stopped(g_n)$ e sua semântica indica que o objetivo $g_n$ teve sua execução encerrada. 

O predicado $nextGoal(g_i,g_j) |g_i, g_j \in Goal$ possui a seguinte semântica: O objetivo $g_i$ tem um próximo objetivo que é $g_j$. Sua necessidade advêm do fato de que este modelo trabalha os mesmos conceitos presentes em \textit{MOISE+} porém sob uma abordagem diferente. Em vez de usar estrutura de super-sub objetivos e definindo operadores de série e paralelo, os objetivos não possuem estruturas, e suas relações se dão por um objetivo apontado para o próximo. Então, para exemplificar pode-se considerar uma atividade descrita por quatro objetivos, sendo que $g_0$ é pré-requisito para $g_1$ e $g_2$. Em contrapartida $g_3$ só começa a ser atingido depois da finalização de $g_1$ e $g_2$. Assim sendo, na linguagem proposta neste estudo, esse problema é escrito da seguinte forma: $nextGoal(g_0,g_1), nextGoal(g_0,g_2), nextGoal(g_1,g_3), nextGoal(g_2,g_3)$.

O predicado $requiresCirc(goal_i,circ_j) | goal \in Goa, circ_j \in Circumstance, Relation \subset Circumstace, Condition \subset Circumstance$ é lido da seguinte forma: Para que o objetivo $goal_i$ possa ser alcançado é necessário a circunstância $circ_j$. Essa circunstância pode ser tanto relações $relation \in Relation$ ou pode ser condições $c_k$.

O predicado $requiresEntity(goal_i, e_j) | g_i \in Goal, e_j \subset Entity $ é lido da seguinte forma: Para que o objetivo $g_i$ seja atingido, as entidades $e_j$ devem estar presentes no instante em que $g_i$ estiver sendo alcançado. O propósito deste predicado reside na necessidade de identificar quais são as entidades que devem estar presentes para que um dado objetivo possa ser executado. No \textbf{Exemplo da Redação}, um objetivo $g_2$ só pode ser atingido se as entidades $\{ aluno, folha, lapis\}$ estiverem presentes no momento em que $g2$ estiver sendo alcançado. Esse cenário é representado da seguinte forma; $requiresEntity(g_2, aluno), requiresEntity(g_2, folha), requiresEntity(g_2, lapis)$.

O predicado $isPresent(circ_i) | circ_i \in Circumstance $ retorna como verdade de $circ_i$ está presente no momento em que este predicado é invocado (retorna falso para o contrário). Em alguns raciocínios é de importância verificar se um elemento está presente durante a tentativa de uma dado agente executar algum objetivo.

O predicado $starts(ag_i,g_j) | ag_i \in Agent \wedge g_j \in Goal $ é lido da seguinte forma: Um agente $ag_i$ está tentando atingir o objetivo $g_j$. Para algumas situações, é de crucial importância identificar quando um agente está tentando atingir um objetivo, sendo necessário a existência de um predicado apenas para esse propósito. Para exemplificar, pode-se considerar o exemplo da redação. Para que o professor $Aristoteles$ possa alcançar o objetivo $g_0$, é necessário a existência de uma tentativa. Neste modelo, essa situação é representada da seguinte maneira: $starts(aristoteles,g_0)$. Seguindo a linha desse predicado, há também o $ableReach(ag_i,g_j) | ag_i \in Agent \wedge g_j \in Goal$ cuja semântica expressa que o agente $ag_i$ está habilitado a tentar buscar o objetivo $g_j$. Contudo, não significa que o agente fará o correspondente de $starts(ag_i,g_j)$. O que definirá a transição de $ableReach(ag_i,g_j)$ para $starts(ag_i,g_j)$ são os estados internos do agente. Contudo, não é do interesse deste estudo aprofundar na dinâmica do agente em si, deixando esse processo em aberto para o programador decidir como resolverá essa questão.

O predicado $ conditionViol(ag_i,g_j,c_k) | ag_i \in Agent \wedge g_k \in Goal \wedge c_k \in Condition$ deve ser lido da seguinte maneira: O agente $ag_i$ comete uma violação de condição no objetivo $g_j$ por tentar realizar uma determinada atividade em que a condição $c_k$ era essencial porém não estava presente. Os fundamentos deste predicado está vinculado com a seção \ref{normasdastani}. No modelo em \ref{normasdastani} para representar aspectos normativos dos agentes, a regra do tipo \textit{Count-as} apresenta quais são as circunstâncias que ocasionam uma violação. Esse predicado cumpre esse propósito para o conjunto \textbf{Conditions}. Para exemplificar, no \textbf{Exemplo da Redação}, se o professor Aristóteles lecionar sem que haja luz suficiente para isso, então ele cometeu uma violação de condição caracterizada da seguinte maneira: $conditionViol(aristoteles,g_0,luz)$

O predicado $ relationViol(ag_i,g_j,r_k) | ag_i \in Agent \wedge g_k \in Goal \wedge r_k \in Relation $ possui a mesma situação presente em $ conditionViol(ag_i,g_j,c_k) $ contudo o foco diz respeito aos relacionamentos. A leitura se dá desta forma: O agente \textit{ag\_i} pratica uma violação de relação no objetivo $g_j$ por executar a atividade sem que a relação $r_k$ esteja presente. O uso deste predicado por ser feito considerando o exemplo em análise com a adição de uma breve descrição de uma situação que possa ocorrer que é o seguinte; A ponta do lápis que Alexandre tenta usar para escrever a redação está quebrada. Portanto, a relação \textit{relLapisFolha} não pode ser feita. Se o agente \textit{Alexandre} alcançar o objetivo $g_2$ sem ter as circunstâncias necessárias para isso, então comente uma violação de relação sendo escrito da seguite forma: $relationViol(alexandre,g_2,r_2)$.

O predicado $ entityViol(ag_i,g_j,e_k) ag_i \in Agent \wedge g_j \in Goal \wedge e_k \in Entity$ advém das mesmas situações dos dois predicados a cima. A leitura deste predicado se dá da seguinte forma: O agente $ag_i$ cometeu uma violação por tentar alcançar o objetivo $g_j$ sem que a entidade $e_k$ esteja presente. No exemplo padrão o uso deste predicado consiste em Alexandre tentar executar $g_2$ sem ter a entidade lápis o que resulta no seguinte: $entityViol(alexandre, g_2, lapis)$.

O predicado $ hasRisk(crts, risk_j, cs_k) | crts \in Circumstance \wedge  risk_k \in Risk \wedge cs_k \in Consequence $ é baseado nos estudos presentes na seção \ref{risksec} e tem a finalidade de definir os riscos associados ao tentar executar alguma atividade sem que $c_k$ ou $r_k$ esteja presente. Portanto, a leitura deste predicado é dada da seguinte forma; A ocorrência de uma violação onde $crts$ ocasiona em um evento associado ao $risk_j$ com a consequência $cs_k$. Ao explicar sobre o conjunto \textbf{Consequence}, foi dado um exemplo sobre um eletricista que tem o potencial de ser eletrocutado. Para esse exemplo, o uso deste predicado apresenta o seguinte formato: $hasRisk(relFerramentaIsolanteBarramento, eletrocutado, morte)$.

O predicado $possOfNegConseqFor(r_l) | r_l \in Relation $ tem seus fundamentos associados ao estudo da lógica modal, presente na seção \ref{logic}, no operador $\Diamond$ cuja semântica denota possibilidade. Contudo, neste estudo esse termo apresenta o seguinte conceito semântico: há a possibilidade de acontecer um evento ruim associado ao risco $r_l$ vinculado ao agente que está associado a essa relação, mesmo que esse agente não tenha cometido nenhum erro durante o procedimento. Esse predicado tem como por finalidade representar situações onde um evento ruim acontece, não pelo erro do profissional diretamente associado a situação, mas sim por outras cadeias causais complexas de serem identificadas e justamente por isso são abstraidas por conceitos de aleatoriedades, idem possibilidades. Para exemplificar pode-se considerar a situação onde um eletricista de linha viva usa um bastão isolante para acessar um barramento altamente energizado. Contudo, esse bastão pode estar com isolamento comprometido. Testes que devem ser feitos antes de fazer uso de uma ferramenta podem eliminar qualquer possibilidade de que os riscos venham a se tornar eventos reais, pois se o bastão em questão estiver em bom estado, então o eletricista não se envolverá em um acidente por esse fator. Se o bastão estiver em mal estado - isso será identificado e a ferramenta será adequadamente substituída. Contudo, considerando um cenário onde por negligencia de profissionais a medição não é feita, surge uma possibilidade do isolamento estar comprometido. Essa situação torna verdade o seguinte predicado $possOfNegConseqFor(relBastaoBarramento)$.

O predicado $affectsRels(r_k,r_n) | \{ r_k, r_n\} \subset Relation $ trabalha em conjunto $possOfNegConseqFor(r_l)$. Esse predicado se lê da seguinte forma: Se $r_k$ não foi realizado, ou se for realizado de forma inapropriada, isso afeta  $r_n$ tornando verdade $possOfNegConseqFor(r_n)$. Ambos são importantes em raciocínios onde se deseja mostrar que a não execução de uma relação não gera consequências negativas imediatas a ninguém, mas resulta em consequências futuras inclusive sobre pessoas que não compartilham da mesma situação. No exemplo do eletricista, a relação $relBastaoBarramento$ é afetada pela não execução da relação $relBastaoMedidor$ (que define a relação entre o aparelho medidor de corrente de fulga e o bastão isolante). Esse exemplo é escrito da seguinte maneira:$affectsRels(relBastaoMedidor,relBastaoBarramento)$

O predicado $negConseqFor(g_k, ag_i,risk_k,cs_m)$ pode ser lido da seguinte maneira; ocorreu um evento ruim no objetivo $g_k$ associado ao agente $ag_i$ e associado ao risco $risk_k$ que atribuiu ao agente $ag_i$ consequências $cs_m$. Esse predicado tem por finalidade traduzir semanticamente as consequências ruins sobre alguém quando ocorre o pior caso. Sobre o exemplo do eletricista que acessa um barramento de alta tensão, esse predicado é escrito da seguinte forma: $negConseqFor(g_{acessoBarramento}, eletricista,eletrocutado,morte)$. Associado a isso há o predicado $happensNegConseqFor(r_m)$ cujo propósito define que um evento ruim aconteceu no relacionamento $r_m$.

O predicado $lastGoal(g_i,\rho_m) | g_i \in Goal, \rho_m \in Role $ apresenta um último objetivo $g_i$ que deve ser alcançado por agentes com determinado papel $\rho_{m}$. Esse predicado tem sua existência justificada em certos raciocínios, que serão demonstrados mais adiante, onde esse tipo de informação é relevante.