A regra \ref{reldeonticrole} tem os fundamentos teóricos na lógica deôntica e em modelos como \textit{MOISE+}. Assim sendo, todas as relações de obrigação implicam relações de permissão. O que essa regra determina consiste no fato de que se um agente $g_j$ é obrigado a trabalhar sobre o objetivo $g_j$, então esse agente também tem a permissão de para trabalhar sobre o objetivo $g_j$ 

\begin{eqnarray}\label{reldeonticrole}
	hasObligation(\rho_m,g_j) \to hasPermission(\rho_m,g_j), \nonumber \\
    \rho_m \in Role \wedge g_j \in Goal
\end{eqnarray}

As regras \ref{violationcondition}, \ref{violationrelation}, e \ref{violationentity} são fundamentadas em \ref{normasdastani} onde o conceito do que pode ou não pode ser feito é definido em termos das regras \textit{Count-as}. Essas regras determinam quais são os elementos que resultam em violação. Inspirando nesse tipo de estrutura é que os pesquisadores trataram de trabalhar as referidas regras. 

A complexidade de estudo é extramente ampla, e com certeza existe mais tipos de violações do que as consideradas a seguir, contudo optou-se por estudar essas violações porque são essenciais para os objetivos deste estudo. Outro questionamento que pode surgir consiste no porque definir três tipos de violações? Isso reside no fato de que essas violações resultam em consequências diferentes, por conta disto em um primeiro momento os engenheiros do modelo decidiram trata-las em estruturas diferentes. 

A explicação das regras será feita sempre analisando a semântica do predicado que é implicado e em relação aos estudos pelos quais elas se fundamentam. Partindo desta premissa o entendimento da relação \ref{violationcondition} só pode ser feito na ocorrência de uma  investigação sobre quais são os elementos que semanticamente correspondem ao predicado $violationCondition(ag_m,g_i,c_k)$. O primeiro ponto reside em verificar quais são as condições necessárias de $g_i$. Quem tem essa finalidade é o predicado $hasCondition(g_i,cg_n)$. Contudo, saber todas as condições não são o suficientes, pois a violação acontece na ausência de uma condição $c_k$ e isso deve ser verificado nesta relação de implicabilidade. Então se faz necessário considerar um predicado que analisa se $c_k$ está presente no ato da manutenção e é com esse propósito que $isPresent(c_k)$ faz parte da relação. Contudo, as informações ficam desencontradas se $c_k$ não estiver contido em $cg_n$, por isso é de importância fazer essa análise também. Para isso, neste estudo, os pesquisadores fizeram uso de um operador de conjuntos cujo simbolo é $\in$ que nessas relações tem a finalidade de verificar se $c_k$ está contido em $cg_n$. Esses são componentes essenciais, porém não são suficientes porque não consideram a condição do agente. Isso, pois afirmar sobre a ocorrência de uma violação sobre um agente sem considerar se ele esta efetivamente tentando alcançar um objetivo consiste em desconsiderar a semântica daquilo que está sendo implicado. Isso é resolvido por considerar o termo  $tryReach(ag_m,g_i)$. 

\begin{eqnarray}\label{violationcondition}\nonumber
	hasCondition(g_i,cg_n) \wedge \neg isPresent(c_k) \wedge (c_k \in cg_n) \wedge tryReach(ag_m,g_i) \to \nonumber \\  
	violationCondition(ag_m,g_i,c_k) \nonumber \\  
    g_i \in Goal, cg_n \subset ConditionGoal, c_k \in Condition, ag_m \in Agent
\end{eqnarray}

O propósito da regra \ref{violationcondition} quando definido em termos de linguagem natural tem a finalidade de exprimir o seguinte: Se um agente tentar executar um dado objetivo sem que haja todas as condições ambientes necessárias para isso, então esse agente comete uma violação de condição neste respectivo objetivo. 

A regra \ref{violationrelation} define as condições que resultam em uma violação de relação. O predicado $violationRelation(ag_m,g_i,r_k)$ considerada que a violação se dá por um agente $ag_m$ em um objetivo $g_i$ na relação $r_k$. Portanto, para respeitar a semântica deste predicado se faz necessário considerar ao menos um termo que vincule o objetivo $g_i$ com a relação $r_k$. Para esse propósito é que se considera o termo $hasRelation(g_i,rg_n)$ pois define quais são as relações que devem estar presentes para que o objetivo $g_i$ possa ser alcançado. Contudo, só isso não é o suficiente, pois se faz necessário analisar se $r_k$ está presente ou não e se pertence ao conjunto $rg_n$. A primeira situação é resolvida considerando o termo $isPresent(r_k)$ e a segunda situação é resolvida verificando se $r_k \in rg$. A semântica de $violationRelation$ só é conservada em sua inteireza se a presença do agente também for analisada. Para esse propósito é que se verifica a necessidade do uso de $tryReach(ag_m,g_i)$ que deverá retornar se o agente está tentando alcançar o objetivo $g_i$.   

\begin{eqnarray}\label{violationrelation}\nonumber
	hasRelation(g_i,rg_n)\wedge \neg isPresent(r_k) \wedge (r_k \in rg_n) \wedge tryReach(ag_m,g_i) \to \nonumber \\
	violationRelation(ag_m,g_i,r_k) \nonumber \\  
    g_i \in Goal, rg_n \subset RelationGoal, r_k \in Relation, ag_m \in Agent
\end{eqnarray}

Traduzindo a regra \ref{violationrelation} para linguagem natural obtêm-se a seguinte expressão: Se um agente tentar alcançar um dado objetivo sem que todas as relações necessárias para isso estejam presentes (considerando as relações sobre o domínio dele, tal como manuseio de uma dada ferramenta específica, e considerando as relações que são independente dele), então esse agente comete uma violação de relação. 

A regra \ref{violationentity} tem o propósito de definir quais são as condições que resultam em uma violação de entidade. O predicado $violationEntity(ag_m,g_i,e_k)$ define semanticamente que uma violação de entidade corresponde em relação a um dado $ag_m$ em um $g_i$ vinculado a entidade $e_k$. Assim como nas demais regras de violação, o sentido deste termo considera a necessidade de verificar a existência de uma entidade necessária para um dado objetivo, por isso é essencial verificar o predicado $hasEntity(g_i,eg_n)$, verificar se $e_k \in eg_n$ e verificar se $e_k$ está ou não presente no momento da manutenção $isPresent(e_k)$. A semântica do predicado também considera o momento em que o agente está atuando sobre o objetivo $g_i$, por isso o predicado $tryReach(ag_m,g_i)$ também é posto na relação de implicabilidade.

\begin{eqnarray}\label{violationentity}\nonumber
	hasEntity(g_i,eg_n) \wedge \neg isPresent(e_k) 	\wedge (e_k \in eg_n) \wedge tryReach(ag_m,g_i) \to \nonumber \\ 
    violationEntity(ag_m,g_i,e_k)  \nonumber \\  
    g_i \in Goal, eg_n \subset EntityGoal, e_k \in Entity, ag_m \in Agent
\end{eqnarray}

Em termos de linguagem natural, \ref{violationentity} se apresenta da seguinte forma: Se um agente tentar alcançar um dado objetivo sem ter todas as entidades presentes para isso, então esse agente cometeu uma violação de entidade.

As regras \ref{consviolationcondition} e \ref{consviolationrelation} são inspiradas nos estudos presentes na seção \ref{normasdastani} onde as consequências de uma violação são definidas como sanções no que é denominado por $Sanction Rule$. A estrutura dessas regras, em \ref{normasdastani} e em \cite{dastaniframework} é dada como $violation \to ... $. Contudo, este estudo leva em consideração não apenas o termo que se refere a violação, mas também as circunstâncias que são consideradas juntos, que neste caso advêm do predicado $hasRisk$. Assim como em \ref{normasdastani}, o modelo deste estudo define que uma sanção corresponde a uma penalidade que o agente deve pagar. Na estrutura da problemática em análise, a penalidade ocorre pelo fato do agente sofrer fisicamente os efeitos dos seus erros. Esse comportamento é dado pelo predicado $consequenceOfBadEvent(g_i,ag_m,risk_j,cs_m)$ cujo correspondente semântico define que o agente $ag_m$ sofre sobe o evento associado em $risk_j$, no objetivo $g_i$ a consequência $cs_m$. Se os engenheiros deste modelo considerarem apenas $violationCondition(ag_m,g_i,c_k)$ para a relação \ref{consviolationcondition} e $violationRelation(ag_m,g_i,r_k)$, o correspondente semântico de $consequenceOfBadEvent(g_i,ag_m,risk_j,cs_m)$ é desrespeitado, não especificando $risk_j,cs_m$. Contudo, isso é resolvido por levar em consideração o predicado $hasRisk(c_k,risk_j,cs_m)$ para \ref{consviolationcondition} e o predicado $hasRisk(r_k,risk_j,cs_m)$ para \ref{consviolationrelation}. 

\begin{eqnarray}\label{consviolationcondition}\nonumber
	violationCondition(ag_m,g_i,c_k)  \wedge hasRisk(c_k,risk_j,cs_m) \to \nonumber \\ 
	consequenceOfBadEvent(g_i,ag_m,risk_j,cs_m) \nonumber \\ 
    ag_m \in Agent, g_i \in Goal, c_k \in Condition, risk_k \in Risk, cs_m \in Consequence
\end{eqnarray}

Em termos de linguagem natural, a relação em \ref{consviolationcondition} é definida da seguinte maneira: "Uma violação de condição sobre um determinado agente, em um dado objetivo ocasiona em uma consequência ruim a ele. Essa consequência ruim está associada ao risco da condição violada". 

\begin{eqnarray}\label{consviolationrelation}\nonumber
	violationRelation(ag_m,g_i,r_k) \wedge hasRisk(r_k,risk_j,cs_m) \to \\ 
	consequenceOfBadEvent(g_i,ag_m,risk_j,cs_m) \nonumber \\ 
    ag_m \in Agent, g_i \in Goal, r_k \in Relation, risk_k \in Risk, cs_m \in Consequence 
\end{eqnarray}

A regra \ref{consviolationrelation}, quando posto em linguagem natural é definido desta forma: "Uma violação de relação sobre um determinado agente, em um dado objetivo resulta em uma consequência ruim a ele. Essa consequência está atrelada ao risco da relação violada". 

Neste estudo o termo \textit{risco} deve ser analisado com muito cuidado. Isso, pois, dependendo do contexto, a complexidade deste termo é praticamente infinita e neste estudo a concepção deste termo se reduz a dois dos muitos possíveis usos. Neste modelo, risco é analisado como um evento que tem potencial de acontecer, contudo - nas relações de implicação um dos usos do termo risco advêm de considera-lo como evento que acontece apenas na ausência de uma dada condição ou de uma dada relação. Os pesquisadores optaram por essa tratativa ao estudar os conceitos presentes no referencial teórico em \ref{risksec} e ao analisar o caso de estudo (que será apresentado mais tarde). Com base nestes estudos verificou-se que acidentes acontecem porque profissionais tentam executar uma dada atividade sem ter as condições apropriadas 
para isso e é a essa circunstância sobre o qual o risco está associado (em \cite{safety}, isso é explicado visando a melhoria da eficiência e da produção). Por exemplo, para poder navegar em alto mar a fim de poder pescar, um barco pesqueiro deve ter a sua disposição uma dada condição climática. Se a tripulação decidir por navegar sem a presença da condição climática apropriada, então o barco está submetido ao risco de naufragar sobre as consequências de morte da tripulação inteira. Portanto é com essa semântica que as relações de implicação \ref{consviolationcondition} e \ref{consviolationrelation} empregam o conceito de risco. 

Obviamente, existe a possibilidade do barco poder desbravar um mar sem as apropriadas condições e voltar em terra salvo. Contudo, considerar situações assim, apesar de serem interessantes, levam a um aprofundamento da complexidade deste modelo. Não que isso seja uma justificativa coerente para não se fazer isso, contudo - neste estudo o interesse reside em uma primeira versão que torne possível a modelagem de condições assim por meio de um vocabulário mais específico. Assim sendo, os pesquisadores decidiram por simplificar essa situação e considerar que toda a ação tomada por um agente sem que as condições necessárias estejam presentes ou as relações apropriadas sejam feitas resultam em penalidades associadas ao risco da ausência desses elementos.  

Dentro do que condiz ao conceito de sanção que é tratado neste estudo, apenas as regras \ref{consviolationcondition} e \ref{consviolationrelation} são sanções. Isso se deve ao fato de que essas regras consideram que o equivoco do agente gerou penalidades a ele mesmo. Apesar de levar em consideração predicados associados a violação, as demais regras não são consideradas como regras de sanção porque elas apresentam uma condição onde o comportamento inapropriado de um dado agente A resulta em consequências ruins a outros agentes. Como o erro do agente A não recai sobre si, é um inequívoco - dentro do escopo deste estudo - afirmar que ele sofreu uma sanção por conta disto. 


A regra \ref{violationentityaffect} é usada com o propósito de demonstrar que uma dada violação em uma certa relação afeta outras relações. Isso, pois muitas vezes o ato de não executar uma dada relação não gera consequências imediatas no instante a ser considerado, contudo essas consequências se manifestam em relações futuras. Não somente isso, mas a regra \ref{violationentityaffect} também considera um dado componente de aleatoriedade que está atrelado com este tipo de raciocínio. O predicado $possibilityHappensBadEvent(r_n)$ semanticamente corresponde que existe a possibilidade de acontecer algo errado associado ao relacionamento $r_n$. O sentido deste termo é correspondido quando se verifica os elementos que causam este tipo de condição - que no caso desta regra isso envolve a ocorrência de uma violação em $r_k$, sendo que esse relacionamento afeta $r_n$.


\begin{eqnarray}\label{violationentityaffect}
	violationRelation(ag_m,g_i,r_k) \wedge affectsOtherRelations(r_k,r_n) \nonumber \\
    \to possibilityHappensBadEvent(r_n)  \nonumber \\
    ag_m \in Agent, g_i \in Goal, r_k,r_n \in Relation, 
\end{eqnarray}

O entendimento desta regra pode ser feito ao considerar um exemplo que já foi mencionado neste texto ao apresentar o correspondente do predicado \textit{possibilityHappensBadEvent} e o predicado \textit{affectsOtherRelations}, onde um eletricista usa um bastão isolante para acessar um dado barramento. Naquela parte do texto o problema é modelado por meio de duas relações; $relBastaoMedidor$ (que define a relação que deve ser feita entre o bastão isolante com um dado aparelho medidor de correte de fuga) e $relBastaoBarramento$ (que consiste na relação entre o bastão com o barramento elétrico do quadro de energia). Tendo em vista que a ausência de uma medida em $g_{medida}$ afeta a possibilidade de ocorrer algum evento grave em $relBastaoBarramento$, é dado - para esse caso - como verdade o seguinte predicado $affectsOtherRelations(relBastaoMedidor, relBastaoBarramento)$. Assim sendo, em um cenário onde ocorre a violação de relação em $g_{medida}$, o seguinte raciocínio pode ser feito: $violationRelation(eletricista_{medidor},g_{medida},relBastaoMedidor) \wedge affect(relBastaoMedidor, relBastaoBarramento) $ \\ $\to  possibilityHappensBadEvent(relBastaoBarramento)$.   

A regra \ref{violationentityaffect} demonstra como um agente pode ser submetido a consequências ruins sem necessariamente ser culpado por isso. Contudo, essa regra denota apenas possibilidade, não demonstrando o que acontece efetivamente quando o agente é submetido ao lado não favorável da possibilidade. Essa situação está atrelada a \ref{paybutiamnotguilty}. Para lidar com as situações onde um agente é submetido a condições ruins, fez-se o uso do predicado $consequenceOfBadEvent(g_i,ag_m,risk_j,cs_m) $. Entretanto, diferente das regras \ref{consviolationcondition}, \ref{consviolationrelation}, essas consequências negativas tem seus correspondentes semânticos em outros predicados. O predicado $possibilityHappensBadEvent(r_k)$ é invocado com o propósito demonstrar que $r_k$ apresenta a possibilidade da ocorrência de um evento ruim mesmo que o agente que esteja executando essa relação não faça nada de errado. Contudo, esse predicado só denota a possibilidade. Para que o sentido semântico de que a possibilidade de um evento ruim realmente acontece foi considerado o uso do predicado $happensBadEvent(r_k)$. Para o contexto desta regra, a semântica deste predicado exibe o seguinte significado: "O evento ruim associado a essa relação realmente aconteceu". Nesta situação que se faz necessário adotar a outra concepção associada ao termo risco que é adotado a este modelo. Nesta regra, esse termo é adotado como um evento em potencial devido a incerteza associada ao evento. 

Para compreender melhor essa situação é possível voltar ao exemplo do eletricista-bastão isolante-quadro de energia. Como já citado anteriormente o fato do agente medidor não executar sua atividade gera uma incerteza sobre a condição do isolamento do bastão. Se a medida for executada com sucesso (partido do pressuposto de que o medidor está em condições apropriadas de funcionamento), a condição do bastão é revelada eliminando qualquer incerteza a respeito disto. Contudo, como está sendo considerado um cenário onde isso não foi feito, a não execução de $relBastaoMedidor$ resultou no surgimento do risco $eletrocutado$ com uma consequência de morte. Esse risco é dado como um potencial evento até que o eletricista de acesso ao barramento faz uso da ferramenta. Por conta disto, se faz o uso do predicado $hasRisk(r_k,risk_j,cs_m)$. Tendo em vista que isso se dá por uma relação que está atrelada a um objetivo, se faz necessário considerar $hasRelation(g_i,rg_n) \wedge (r_k \in rg_n)$. Para verificar a ação do agente nesta situação, o predicado $tryReach(ag_m,g_i)$ também deve compor a regra.


\begin{eqnarray}\label{paybutiamnotguilty}
	possibilityHappensBadEvent(r_k) \wedge  happensBadEvent(r_k) \wedge hasRelation(g_i,rg_n) \wedge (r_k \in rg_n) \nonumber \\ 
	\wedge hasRisk(r_k,risk_j,cs_m) \wedge tryReach(ag_m,g_i) \nonumber \\ 
	\to consequenceOfBadEvent(g_i,ag_m,risk_j,cs_m) \nonumber \\ 
    r_k \in Relation, g_i \in Goal, rg_n \subset RelationGoal, risk_k \in Risk, cs_m \in Consequence
\end{eqnarray}

O exemplo em voga pode ser implementado nesta regra da seguinte forma: 


\begin{eqnarray}\nonumber
   possibilityHappensBadEvent(relBastaoBarramento) \nonumber \\
    \wedge happensBadEvent(relBastaoBarramento) \nonumber \\ 
    \wedge hasRelation(g_{acessoBarramento},rg_{acessoBarramento}) \nonumber \\  
    \wedge (relBastaoBarramento \in rg_{acessoBarramento}) \nonumber \\ 
    \wedge hasRisk(relBastaoBarramento,eletrocutado,morte) \nonumber \\  
    \wedge tryReach(eletricista_{executor},g_{acessoBarramento}) \nonumber \\ 
    \to consequenceOfBadEvent(g_{acessoBarramento},eletricistaExecutor,eletrocutado,morte) \\ \nonumber
\end{eqnarray}

O exemplo se traduz na situação onde um bastão apresenta uma possibilidade de estar com o seu isolamento comprometido e isso resulta em um risco de eletrocutar o profissional que usa-lo resultando na morte dele. Contudo, o momento da ferramenta ser usada e ao fazer isso o eletricista morre eletrocutado por que esse bastão pertencia as ferramentas cujo isolamento estava deteriorado. 

A violação de entidade, dada pela regra \ref{consvioent} demonstra que a violação de entidade, diferente das demais, resulta apenas no encerramento da atividade no objetivo onde ocorreu. Os engenheiros deste modelo definiram essa regra partindo do pressuposto que a ausência de uma ferramenta, profissional, peça de substituição ou máquina simplesmente gera o impedimento do prosseguimento das atividades. Voltando ao exemplo do eletricista, se o profissional não tiver o bastão isolante para executar a ação, ele simplesmente não consegue dar prosseguimento ao objetivo fazendo com que o procedimento seja encerrado naquele exato instante. 

\begin{eqnarray}\label{consvioent}
	violationEntity(ag_m,g_i,e_k) \to stopIn(g_i) \nonumber \\  
    ag_m \in Agent, g_i \in Goal, e_k \in Entity \\ \nonumber
\end{eqnarray}

Em termos de linguagem natural, a regra \ref{consvioent} é definida da seguinte forma: Se acontecer uma violação de entidades, então o procedimento é encerrado no objetivo onde aconteceu. 

A regra \ref{badcons} advêm do pressuposto de que na ocorrência de uma calamidade onde um profissional sai extremamente ferido ou morto (ocorrência do acidente), os demais envolvidos na manutenção não continuam por executar os procedimentos. 
 
 \begin{eqnarray}\label{badcons}
	consequenceOfBadEvent(g_k,ag_m,risk_j,cs_m) \to stopIn(g_k) \nonumber \\ 
    g_k \in Goal, risk_j \in Risk, cs_m \in Consequence
\end{eqnarray}

Essa regra, no escopo da linguagem natural, pode ser lida desta forma: Se acontecer um evento ruim onde um profissional sai morto ou gravemente ferido, então a manutenção é encerrada no objetivo onde a fatalidade aconteceu. Não há como afirmar que as regras  \ref{consvioent} e \ref{badcons} se aplicam para todo tipo de situação em qualquer procedimento. Operações militares, por exemplo, não se enquadram em situações assim. Isso, pois a morte de um soldado ferido não impede que o resto do batalhão continue em conflito. Contudo, os pesquisadores deste estudo entendem que o pressuposto dessas duas regras englobam diversos cenários que implica no interesse deste estudo, tais como; cenário industrial, subestação, usinas de produção de energia, certas atividades hospitalares e entre outras da mesma natureza.  

A regra \ref{wenStop} define o critério para quando um dado objetivo é considerado como atingido. O primeiro predicado, $stopIn(g_k,ago_n)$ no contexto desta regra define que todos os agentes que tinham permissão para alcançar $g_k$ fizeram isso sem a ocorrência de alguma interrupção (ou seja, não houve nenhum evento onde alguém saiu ferido, morto ou onde alguma dada ferramenta tenha sido esquecida). O termo $(ago_n \subset agg_n)$ denota que os agentes que são obrigados a concluir esse objetivo devem estar contidos em $agg_n$. Se isso não for considerado, a regra \ref{reldeonticrole} entra em contradição com a \ref{wenStop}, pois caso contrário haveria a possibilidade de um objetivo ser considerado como concluído quando agentes que são obrigados a concluir não o fizeram. 

\begin{eqnarray}\label{wenStop}
	\neg stopIn(g_k,agg_n) \wedge (ago_n \subset agg_n) \to isReached(g_k) \nonumber \\ 
    g_k \in Goal, agg_n \in Agg, ago_n \in Ago 
\end{eqnarray}

A linguagem natural essa expressão é dada da seguinte forma: Se todos os agentes que têm permissão para alcançar um dado objetivo fizeram sem que esse tenha sido interrompido e considerando que um subgrupo deles é constituído por agentes que são obrigados a isso, então o objetivo é dado como alcançado.

A regra \ref{rolenextgoal} apresenta a condição adequada para quando um agente está habilitado para atingir novos objetivos. Para isso, ele deve possuir um papel onde existe uma permissão para que ele possa atingir o próximo objetivo. Isso é traduzido por $ hasRole(ag_n,\rho_m) \wedge hasPermission(\rho_m,g_j) $. Não apenas isso, mas o objetivo atual do agente deve ter sido atingido $ isReached(g_i) $ e o objetivo em interesse deve estar associado como predicado $nextGoal(g_i,g_j)$. O termo $ableTryReach(ag_i,g_j)$ corresponde semanticamente apenas que o agente está habilitado para buscar novos objetivos mas não significa que isso implicará em $tryReach(ag_i,g_j)$ pois o que decide esses processos de transição consiste em aspectos que não correspondem a esse modelo. Essa dinâmica é discutida mais tarde na seção de \textit{Predicados Abertos}.

\begin{eqnarray}\label{rolenextgoal}
	hasRole(ag_n,\rho_m) \wedge hasPermission(\rho_m,g_j) \wedge nextGoal(g_i,g_j) \wedge isReached(g_i) \nonumber \\
	\to ableTryReach(ag_i,g_j) \nonumber \\
    ag_i, ag_n \in Agent, \rho_m \in Role, g_j \in Goal, g_i \in Goal
\end{eqnarray}

Em linguagem natural, a regra \ref{rolenextgoal} exibe o seguinte: "Se um agente que alcançou um objetivo atual tem um papel que lhe dá permissão para buscar o próximo objetivo, então esse agente está habilitado para fazer isso"

A regra \ref{rolelastgoal} apresenta a condição de parada do agente em relação ao seu papel. Isso, pois se o agente, que tem um dado papel,
cumpriu com todos os objetivos designados a ele, então ele deve encerrar sua operação. A verificação do papel é dado por $hasRole(ag_n,\rho_m) \wedge hasPermission(\rho_m,g_i)$, a análise semântica sobre o último objetivo associado a um dado papel é dado por $lastGoal(g_i,\rho_m)$ e a verificação se aquele último objetivo foi atingido é dado por $isReached(g_i)$. 

\begin{eqnarray}\label{rolelastgoal}
	hasRole(ag_n,\rho_m) \wedge hasPermission(\rho_m,g_i) \wedge lastGoal(g_i,\rho_m) \wedge isReached(g_i) \nonumber \\
	\to stopIn(g_i) \nonumber \\
    ag_n \in Agent, \rho_m \in Role, g_i \in Goal
\end{eqnarray}

Portanto, a regra \ref{rolelastgoal} em linguagem natural é definida da seguinte maneira; Se um agente cumpriu com todos os objetivos associados a permissão do papel dele, então esse agente deve encerrar suas atividades (em relação a esse papel). 