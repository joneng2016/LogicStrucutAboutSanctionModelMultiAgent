Essa representação pode ser usada para o desenvolvimento de sistemas de informação com muitas possíveis finalidades diferentes. Uma dessas finalidades implica desenvolver um sistema para realizar o planejamento de atividades com o propósito de fazer uma análise dos riscos possíveis. Isso, pois ao especificar uma dada atividade profissional nos moldes desse modelo, o modelador é induzido ao raciocínio de estruturar a atividade em forma de objetivos, é induzido a pensar em todas as entidades e relações importantes, e deve refletir nos riscos e consequências de cada relação e condição. 

Uma outra aplicação para esse modelo consiste em simular as atividades de interesse. 
Essa situação permite que os engenheiros de modelagem realizem diferentes cenários a fim de entender o que realmente acontece com os profissionais nessas condições. Criar um sistema \textit{mobile} para celular (ou qualquer outra forma de computador móvel) a fim de auxiliar os profissionais na execução de uma dada atividade também é outra possível aplicação desse modelo. Por ultimo, esse modelo apresenta potencial para ser usado em jogos sérios com a finalidade de emular algum dado procedimento a fim 
de analisar como os profissionais se comportam em condições de risco. 

Esse estudo fez uso da linguagem de programação \textit{PROLOG} para analisar um estudo de caso. Contudo, outras linguagems podem ser usadas para essa finalidade. Uma dessas é \textit{SQL} onde as classes podem ser definidas por meio de tabelas, as relações entre as classes por meio de chaves estrangeiras e as instâncias por meio de registros. As regras podem ser resolvidas por meio de consultas específicas que são definidas em tabelas temporárias usando condicionadores sentenciais \textit{if ... them ...} em procedimentos específicos para isso. Contudo, a maneira mais prática de tratar as regras consiste em escreve-las em alguma liguagem de programação (estruturado em um algorítmo) que realiza consulta ao banco com as tabelas e relacionamentos do modelo. 

Bancos não relacionais com \textit{MONGO-DB} (usa a estrutura de dados em grafo conhecido com \textit{JSON}) também são apropriados para esse tipo de situação. Esse tipo 
de banco não usa relacionamentos o que apresenta uma dificuldade a mais para a implementação de um modelo dessa natureza, contudo isso pode ser resolvido por forçar os relacionamentos artificialmente na esturutra do banco permitindo consultas similiares as presentes em \textit{SQL}.

Linguagens de programação orientadas a objeto (Java, C$\#$, PHP, C++) também são apropriadas para esse tipo de situação. As classes do modelo podem ser representadas pelas classes da linguagem e os relacionamentos podem ser concebidos por intermédio de métodos. O código pode apresentar um módulo que contem todas as regras do modelo. Assim, 
para cada evento que acontece no sistema, todas as regras são consultadas computando a solução para o dado de entrada. Nessa situação, a especificação é feita instanciando as classes. 

A natureza da implementação deverá ser ponderada com base no uso final do sistema. Para uma situação onde os profissionais necessitam de um sistema para planejar a manutenção, fazer uso de uma estrutura onde a especificação e os relacionamentos são definidos em banco de dados e as regras são estruturada em uma linguagem de programação 
é o melhor caminho. Isso, pois os profissionais terão de escrever registros no sistema diversas vezes durante o seu respectivo uso e isso necessita de uma estrutura preparada para esse trânsito de informação. Em contrapartida, deixar as regras em prol da linguagem de programação permite que o sistema efetive os raciocínios de maneira 
muito mais rápida quando houver necessidade. Nesse modelo o sistema realiza a consulta necessária ao banco de dados, escreve o retorno na memória \textit{RAM} e o computa
nas regras. 

Se a implementação dessa representação for usada em um jogo de computador, escrever as classes, relacionamentos, instâncias e regras em uma linguagem de programação eliminando o uso de banco de dados é a alternativa mais interessante nessa situação. Isso se deve ao fato de que muitas vezes um jogo necessita de alta-performance para 
funcionar. Eliminar o banco de dados evita o tempo de consulta a memórias lentas removendo um tempo computacional significativo. Se se os profissionais optarem por manter 
um banco de dados, devem tentar resolver a situação com o menor número de consultas possíveis - talvez apenas uma ao carregar o jogo, escrevendo todos os dados na memória  
tornando-as disponíveis para serem constantemente computadas nas regras. Contudo, as diferentes maneiras de realizar essa implementação estão em função das demandas finais. 